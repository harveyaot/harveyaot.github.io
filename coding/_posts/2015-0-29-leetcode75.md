---
layout: post
title: sort color [leetcode]
comments: true
---

首先使用的是冒泡排序，时间复杂度O(nlogn), AC5ms

``` c++
class Solution {
public:
    void sortColors(int A[], int n) {
        for(int i=0;i<n;i++){
            for(int j=0;j<n-i-1;j++)
                if (A[j] > A[j + 1]){
                    int tmp = A[j];
                    A[j] = A[j+1];
                    A[j+1] = tmp;
                }
        }
    }
};
```

觉得用冒泡有些大材小用，后来看了后面的discuss，有时间复杂度O(n)的方法,虽然 AC 时间依然是5ms 但是估计跟leetcode的case 有很大的关系，这段代码注意 store2 的时候 n-1,注意边界的判断是<还是<=,另外就是i 何时自加何时不自加

``` c++
class Solution {
public:
    void sortColors(int A[], int n) {
        int i = 0;
        int store0 = 0;
        int store2 = n -1;
        while(i <= store2){
            if (A[i] == 0){
                swap(A[i++],A[store0++]);
            }
            else if (A[i] == 2){
                swap(A[i],A[store2--]);
            }
            else
                i++;
            
        }

    }
};
```
